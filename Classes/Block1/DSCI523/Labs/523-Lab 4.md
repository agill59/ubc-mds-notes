---

title: "DSCI 523 Lab 4"

subtitle: Mapping & nested data frames, as well as tidy evaluation

output:

  pdf_document:

    latex_engine: xelatex

  html_document: default

---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

```

## Lab Mechanics

rubric={mechanics:5}

- All files necessary to run your work must be pushed to your GitHub.ubc.ca repository for this lab.

- You need to have a minimum of 3 commit messages associated with your GitHub.ubc.ca repository for this lab.

- You must also submit `.Rmd` file and the rendered html in this worksheet/lab to Gradescope. Entire notebook must be executed so the TA's can see the results of your work. 

- **There is autograding in this lab, so please do not move or rename this file. Also, do not copy and paste cells, if you need to add new cells, create new cells via the "Insert a cell below" button instead.**

- To ensure you do not break the autograder remove all code for installing packages (i.e., DO NOT have `install.packages(...)` or `devtools::install_github(...)` in your homework!

- Follow the [MDS general lab instructions](https://ubc-mds.github.io/resources_pages/general_lab_instructions/).

- <mark>This lab has hidden tests. In this lab, the visible tests are just there to ensure you create an object with the correct name. The remaining tests are hidden intentionally. This is so you get practice deciding when you have written the correct code and created the correct data object. This is a necessary skill for data scientists, and if we were to provide robust visible tests for all questions you would not develop this skill, or at least not to its full potential.</mark>

## Code Quality

rubric={quality:5}

The code that you write for this assignment will be given one overall grade for code quality, see our code quality rubric as a guide to what we are looking for. Also, for this course (and other MDS courses that use R), we are trying to follow the tidyverse code style. There is a guide you can refer too: http://style.tidyverse.org/

Each code question will also be assessed for code accuracy (i.e., does it do what it is supposed to do?).

## Writing 

rubric={writing:5}

To get the marks for this writing component, you should:

- Use proper English, spelling, and grammar throughout your submission (the non-coding parts).

- Be succinct. This means being specific about what you want to communicate, without being superfluous.

## Let's get started!

Run the cell below to load the libraries needed for this lab, as well as the test file so you can check your answers as you go!

```{r}

library(nycflights13)

library(palmerpenguins)

library(rlang)

library(testthat)

library(readr)

library(dplyr)

library(purrr)

library(tidyr)

library(ggplot2)

```

> Note - there is an issue with loading packages with `tidyverse` and the autograding software we are using.

Thus, for assignments, please load the packages individually as I have done above instead of loading them via the tidyverse.

## Exercise 1: nesting

rubric={accuracy:10,reasoning:5}

Using the {palmerpenguins} `penguins` data set, demonstrate the use of `nest` and `unnest`. First create a data frame where all data, except for the `species` and `island` columns are nested into one column named `data`. Then demonstrate how you can unnest this data frame so that you get back the original data frame.

In 2-3 sentences, explain what kind of column the nested data became. What was the type of the elements inside that column? Comment on their dimensions.

The `data` column in `nested_data` contained the remaining 6 columns and however many observations each combination of species and island had. For example, `species == Adelie` and `island == Dream` has 56 observations, so the `data` column is a tibble of size `56x6`. 

```{r}

nested_data <- penguins %>%

  nest(c(bill_length_mm:year))

unnested_data <- nested_data %>%

  unnest(data)

unnested_data

```

## Exercise 2: mapping and nesting

rubric={autograde:10,reasoning:5}

Working with the {nycflights13} `weather` data set which contains hourly

meterological data for LGA, JFK and EWR, obtain the minimum, maximum and

average temperature for each month for each origin without dropping the 

rest of the data in the data frame. Keep all the data associated with the 

monthly records for each origin in the same row as the summary statistics 

you calculate for that record. You will have to nest the data to do this.

Name your tibble `weather_nested`.

The {tidyr} `nest`, {dplyr} `mutate` and {purrr} `map` functions should 

allow you to accomplish this. Your resultant data frame should contain the following 6

columns: `origin`, `month`, `data` (nested data frames), `min_temp`,

`max_temp` and `avg_temp`.

Look at your output, and consider the other way you could have arrived at your

summary statistics (`group_by` + `summarise`). What would have been different 

about your results had you obtained them that way instead? Explain this in 1-2 

sentences.

With (`group_by` + `summarise`), we lose the data columns since the only columns that remain are the summary statistics as well the columns we grouped by. 

```{r}

weather_nested <- weather %>%

  nest(c(year:time_hour, -month)) %>%

  mutate(min_temp = map_dbl(data, ~ min(.$temp, na.rm = TRUE))) %>%

  mutate(max_temp = map_dbl(data, ~ max(.$temp, na.rm = TRUE))) %>%

  mutate(avg_temp = map_dbl(data, ~ mean(.$temp, na.rm = TRUE)))

weather_nested

# Below code was done to answer reasoning above

# limbo <- weather %>%

#   group_by(origin, month) %>%

#   summarise(min_temp = min(temp, na.rm = TRUE),

#             max_temp = max(temp, na.rm = TRUE),

#             avg_temp = mean(temp, na.rm = TRUE))

# limbo

```

The tests below only check that the object has the correct names. The other tests are intentionally hidden.

```{r}

. <- ottr::check("tests/e2.R")

```

## Exercise 3: programming with {dplyr}

rubric={accuracy:5,reasoning:5}

Write a wrapper function for the {dplyr} `filter` + {stringr} `str_detect` functions to create a function to filter for rows that contain a full or partial string match. Your function should take a data frame, an unquoted column name (not as a string), and a string pattern to search for. It should return a data frame with rows that match the pattern searched for in the column specified. Follow good software development practices:

- document your function using `roxygen2`

- deal with erroneous user inputs

- write tests to ensure that your function works as expected

*Hint: yet again you will want to generate some helper data for your tests...*

```{r error=TRUE}

#' Filter rows of a data frame where a character column matches a pattern

#'

#' @param data A `data.frame` or tibble containing at least one column.

#' @param col_name A column name (unquoted) to check. Must be of type character.

#' @param pattern A character string with a regular expression pattern

#'   passed to [stringr::str_detect()]. Must not be empty.

#'

#' @return A tibble or data frame with the same number of rows as `data`

#'   where `col_name` matches `pattern`. Only the selected column is returned.

#'

#'

#' @examples

#' filter_string(

#'   data.frame("chr" = c("abc", "bcd", "a.bc", "a bc", ".bcd")),

#'   chr, "a"

#' )

filter_string <- function(data, col_name, pattern) {

  if (!"character" %in% sapply(data, typeof)) {

    fail("Dataframe has no character columns")

  }

  if (!"character" %in% typeof(data %>% pull({{ col_name }}))) {

    fail("Selected column is not of type character")

  }

  data %>%

    tryCatch(filter(stringr::str_detect({{ col_name }}, pattern)))

}

test_data <- data.frame("chr" = c("abc", "bcd", "a.bc", "a bc", ".bcd"))

test_data

solution_1 <- data.frame("chr" = c("abc", "a.bc", "a bc"))

expect_equal(filter_string(test_data, chr, "a"), solution_1)

test_data_no_chr <- data.frame("col1" = c(1, 2, 3, 3, 5))

expect_failure(filter_string(test_data_no_chr, col1, ""))

test_col_no_chr <- data.frame(

  "col1" = c(1, 2, 3, 3, 5),

  "chr" = c("abc", "bcd", "a.bc", "a bc", ".bcd")

)

expect_failure(filter_string(test_col_no_chr, col1, ""))

# Error being pattern cannot be empty string

expect_error(filter_string(test_col_no_chr, chr, ""))

```

## Exercise 4: programming with {dplyr} when there is reassignment

rubric={accuracy:10,reasoning:5}

Write a wrapper function for the {dplyr} `mutate` + {stringr} `str_replace` functions to create a function that can change a single value in an **already existing** character vector in a data frame in a less verbose way. As inputs, your function should take a data frame, an unquoted column name (not as a string), a string pattern to search for, and a string replacement value. It should return a data frame with the specified column modified. Follow good software development practices:

- document your function using `roxygen2`

- deal with erroneous user inputs

- write tests to ensure that your function works as expected

*Hint: yet again you will want to generate some helper data for your tests...*

```{r error=TRUE}

#' Replace string values in a character column

#'

#' @param data A data frame containing the column to modify.

#' @param col_name A column name (unquoted) indicating which character column 

#'   to modify.

#' @param pattern A string (or regex) pattern to search for in the column.

#' @param replacement A string to replace the matched pattern with.

#'

#' @return A data frame with the specified column modified, where all matches 

#'   of \code{pattern} are replaced by \code{replacement}.

#'

#' @examples

#' replace_string(test_data, chr, "abc", "cap")

replace_string <- function(data, col_name, pattern, replacement) {

  if (!"character" %in% sapply(data, typeof)) {

    fail("Dataframe has no character columns")

  }

  if (!"character" %in% typeof(data %>% pull({{ col_name }}))) {

    fail("Selected column is not of type character")

  }

  data %>%

    mutate({{ col_name }} := tryCatch(stringr::str_replace(

      {{ col_name }},

      pattern,

      replacement

    )))

}

test_data <- data.frame(

  "chr" = c("abc", "bcd", "a.bc", "a bc", ".bcd"),

  "col1" = c(1, 2, 3, 4, 5)

)

solution_1 <- data.frame(

  "chr" = c("cap", "bcd", "a.bc", "a bc", ".bcd"),

  "col1" = c(1, 2, 3, 4, 5)

)

solution_2 <- data.frame(

  "chr" = c("axc", "xcd", "a.xc", "a xc", ".xcd"),

  "col1" = c(1, 2, 3, 4, 5)

)

expect_equal(replace_string(test_data, chr, "abc", "cap"), solution_1)

expect_equal(replace_string(test_data, chr, "b", "x"), solution_2)

expect_error(replace_string(test_data, chr, "abc", 1))

expect_error(replace_string(test_data, chr, 1, "cap"))

```

## Exercise 5: (Challenging question)

rubric={accuracy:3,reasoning:2}

This same tidy evaluation can be used to program with {ggplot2} functions! Take the code below to make a two dimensional scatter plot where the points are coloured by a categorical variable, with the economist theme and turn it into a single function call where all the user needs to specify is:

```

economist_scatter(data, x, y, colour_by)

```

Which should return a plot object the user could save using `ggsave` or call to display in a rendered document. Important - this function should work for any data frame that has two (or more) quantitative variables and one (or more) categorical variables. 

```

library(ggthemes)

library(palmerpenguins)

ggplot(penguins, aes(x = body_mass_g, y = flipper_length_mm)) +

    geom_point(alpha = 0.5, size = 2, aes(colour = sex)) +

    theme_economist()

```

> Note: You do not have to write tests for this function (this is challenging and we will learn how to do this DSCI 524)

```{r}

# YOUR CODE HERE

```

> Note - there is a new {tidyverse} function, `across`, that is also useful for applying a function across columns (docs: https://dplyr.tidyverse.org/reference/across.html), however we focus on teaching `map_*` in MDS as it is more general. Feel free to use either in future if the use of `map_*` is not specified.

Congratulations! You are done the lab!!! Pat yourself on the back, and submit your lab to **GitHub** and Gradescope! Make sure you have 3 Git commits!